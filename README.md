

```markdown
# âš™ï¸ Full Adder in Verilog (Combinational Logic)

This project demonstrates the implementation of a **1-bit Full Adder** using **Verilog HDL**, along with its **testbench** for behavioral simulation in **Xilinx Vivado**.

---

## ğŸ§  Project Overview

A **Full Adder** is one of the most fundamental combinational logic circuits used in digital electronics.  
It performs binary addition of three one-bit numbers:

- **Input A** â€” First operand  
- **Input B** â€” Second operand  
- **Carry In (Cin)** â€” Input carry from a previous lower significant bit  

The Full Adder produces two outputs:

- **Sum (S)** â€” The binary sum of the three inputs  
- **Carry Out (Cout)** â€” The carry bit generated when the sum exceeds 1  

---

## ğŸ“˜ Theoretical Background

A **Half Adder** can only add two binary bits (`A` and `B`).  
A **Full Adder**, on the other hand, adds three bits (`A`, `B`, and `Cin`) by combining two Half Adders and an OR gate.

The Boolean expressions for the Full Adder are:

```

Sum  = A âŠ• B âŠ• Cin
Cout = (A Â· B) + (B Â· Cin) + (A Â· Cin)

````

Where:  
- `âŠ•` â†’ XOR operation  
- `Â·` â†’ AND operation  
- `+` â†’ OR operation  

---

## ğŸ§® Truth Table

| A | B | Cin | Sum | Cout |
|:-:|:-:|:-:|:-:|:-:|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

---

## ğŸ’» Verilog Design â€” `full_adder.v`

```verilog
module full_adder(
    input a, b, cin,
    output sum, cout
);
    assign sum  = a ^ b ^ cin;                  // XOR for sum
    assign cout = (a & b) | (b & cin) | (a & cin); // Carry logic
endmodule
````

### ğŸ” Explanation:

* The **sum** is produced by XOR-ing all inputs.
* The **carry** is generated by considering all pairs that can produce a carry.
* This design is purely **combinational** (no clock, no flip-flops).

---

## ğŸ§ª Testbench â€” `full_adder_tb.v`

```verilog
`timescale 1ns / 1ps

module full_adder_tb;

    reg a, b, cin;
    wire sum, cout;

    // Instantiate Unit Under Test (UUT)
    full_adder uut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $monitor("Time=%0t | a=%b b=%b cin=%b | sum=%b cout=%b", 
                 $time, a, b, cin, sum, cout);

        // Apply all possible input combinations
        a=0; b=0; cin=0; #10;
        a=0; b=0; cin=1; #10;
        a=0; b=1; cin=0; #10;
        a=0; b=1; cin=1; #10;
        a=1; b=0; cin=0; #10;
        a=1; b=0; cin=1; #10;
        a=1; b=1; cin=0; #10;
        a=1; b=1; cin=1; #10;

        $display("Simulation completed successfully!");
        $finish;
    end

endmodule
```

### ğŸ§  How the Testbench Works:

* **Registers** (`a`, `b`, `cin`) act as input drivers.
* **Wires** (`sum`, `cout`) capture module outputs.
* `$monitor` continuously displays real-time signal changes.
* Eight combinations (`2^3`) are tested with a delay of 10 ns each.

---

## â–¶ï¸ Running the Simulation (Vivado)

1. **Create a New Project**

   * Name: `combinational`
   * Type: *RTL Project*
   * Add `full_adder.v` as **Design Source**
   * Add `full_adder_tb.v` as **Simulation Source**

2. **Run Behavioral Simulation**

   * Click: **Flow Navigator â†’ Run Simulation â†’ Run Behavioral Simulation**

3. **View Outputs**

   * **Tcl Console:** Displays text output (`$monitor` values)
   * **Waveform Window:** Displays logic transitions for `a`, `b`, `cin`, `sum`, and `cout`

---

## ğŸ“Š Expected Simulation Output (Console)

```
Time=0  | a=0 b=0 cin=0 | sum=0 cout=0
Time=10 | a=0 b=0 cin=1 | sum=1 cout=0
Time=20 | a=0 b=1 cin=0 | sum=1 cout=0
Time=30 | a=0 b=1 cin=1 | sum=0 cout=1
Time=40 | a=1 b=0 cin=0 | sum=1 cout=0
Time=50 | a=1 b=0 cin=1 | sum=0 cout=1
Time=60 | a=1 b=1 cin=0 | sum=0 cout=1
Time=70 | a=1 b=1 cin=1 | sum=1 cout=1
Simulation completed successfully!
```

---

## ğŸ“ˆ Waveform Example (Expected)

| Signal        | Description                             |
| ------------- | --------------------------------------- |
| **a, b, cin** | Input signals applied sequentially      |
| **sum**       | Changes according to XOR of inputs      |
| **cout**      | Goes high when two or more inputs are 1 |

The waveform in Vivado will show clear logical transitions at every 10 ns step.

---

## ğŸ§° Tools & Environment

| Tool                         | Version / Type           |
| ---------------------------- | ------------------------ |
| **Vivado**                   | 2020.2 or later          |
| **Language**                 | Verilog HDL              |
| **Simulation Type**          | Behavioral               |
| **Design Type**              | Combinational Logic      |
| **Target Device (optional)** | Artix-7 / Spartan-6 FPGA |

---

## ğŸ¯ Learning Outcomes

After completing this project, you will:

* Understand the design of **combinational circuits** using Verilog.
* Learn how to write and execute **testbenches** for simulation.
* Explore **bitwise logic operations** (`AND`, `OR`, `XOR`).
* Be comfortable with **Vivado simulation environment** and waveform analysis.

---

## ğŸ“‚ Repository Structure

```
â”œâ”€â”€ full_adder.v          # Full Adder Verilog design
â”œâ”€â”€ full_adder_tb.v       # Testbench for simulation
â””â”€â”€ README.md             # Documentation (this file)
```

---

## ğŸ“˜ Additional Notes

* You can expand this project to create a **4-bit Ripple Carry Adder** by connecting four 1-bit Full Adders in series.
* This is an essential building block for understanding **Arithmetic Logic Units (ALUs)** and **processor design**.

---

## ğŸ‘¨â€ğŸ’» Author

**Abhisekh Barman**
ğŸ’» Electronics & Computer Enthusiast | Learning Digital Design, Computer Architecture, and Verification
ğŸ“§ *[Email Me](mailto:your.email@example.com)*
â­ *If you found this project helpful, please star the repository!*

---

## ğŸª„ Keywords

`Verilog` Â· `Vivado` Â· `Full Adder` Â· `Combinational Logic` Â· `Digital Design` Â· `FPGA` Â· `Testbench`

---

```

---

âœ… **How to use:**
1. Copy all the text above.  
2. Open your project folder â†’ open or create `README.md`.  
3. Paste the content and save.  
4. Commit and push to GitHub â€” your repo will now have a perfect formatted README page.  

